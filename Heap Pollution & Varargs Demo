import java.util.*;

/**
 * 
 * // ===== DEFINITIONS =====

    // VARARGS (Variable Arguments): 
    //  Method parameter syntax `Type... name` accepts 0+ arguments,
    //  auto-converted to array inside method (e.g., `int... nums` ‚Üí `int[]`).
    
    // HEAP POLLUTION: 
    //  When generic-typed reference (erased to raw `Object[]` at runtime) points to heap data
    //  containing wrong/incompatible types, causing ClassCastException.
    
    // @SafeVarargs: 
    //  Annotation on static/final varargs methods to suppress "heap pollution" compiler warnings.
    //  Only safe if method doesn't expose/return/modify the varargs array.
    
    // TYPE ERASURE: 
    //  Java generics lose type info at runtime (List<String> ‚Üí List), enabling heap pollution.
    
    // NON-REIFIABLE: 
    //  Generic types (List<T>) can't be checked at runtime due to erasure (vs. primitives/arrays).
    
    // BRIDGE ARRAY: 
    //  Compiler creates Object[] internally for generic varargs, bypassing type safety.
    
    // KEY RULE: 
    //  Never return generic varargs array T[] or assign to Object[] and insert wrong types!

 * 
 * Complete Demo: Varargs, Heap Pollution, and @SafeVarargs
 * 
 * Compile: javac -Xlint:all HeapPollutionDemo.java  (See warnings!)
 * Run: java HeapPollutionDemo
 * 
 * Sections:
 * 1. Safe varargs with primitives (int...): No issues.
 * 2. Generic varargs warning & subtle pollution (via return/exposure).
 * 3. Direct heap pollution via Object[] cast.
 * 4. @SafeVarargs suppresses warning (but doesn't prevent pollution if misused).
 * 
 * in section-3,
 * OLD JDK 8 and earlier: genericToArray("Hello", "World") ‚Üí Object[]
 * NEW JDK 9+: Smart compiler detects ALL args are String ‚Üí creates String[] directly!
 * That's why: "Varargs array type: class [Ljava.lang.String;" (not Object[])
 * And casting succeeds: String[] strings = genericToArray(...) ‚úÖ
 * And if called: genericToArray("Hello", 123) -> Object[] then throws compile-time exception/error:

    Why compile-time error (good!):
    
    Compiler sees String[] assignment ‚Üí infers T=String
    
    "Hello" ‚úÖ String, but 123 ‚Üí autoboxes to Integer ‚ùå String
    
    Type mismatch caught BEFORE runtime üéâ

    
    | Scenario                                | Compile?   | Runtime? | Why                     |
    | --------------------------------------- | ---------- | -------- | ----------------------- |
    | genericToArray("Hello", 123) ‚Üí String[] | ‚ùå Error    | N/A      | Type inference catches  |
    | Object[] objects = stringLists          | ‚úÖ OK       | üí• Crash | Erasure bypasses checks |
    | @SafeVarargs methods                    | ‚ö†Ô∏è Warning | ‚úÖ Safe*  | Annotation + discipline |
 * 
 
 * 
 * Key Takeaway: Varargs with generics create Object[] internally (type erasure).
 * Exposing/returning/modifying leads to runtime ClassCastException.
 * 
 * GitHub Ready: Add this to repo with README explaining output/warnings.
 */
 //HeapPollutionDemo
public class Main {

    // 1. SAFE: Varargs with primitives/non-generics. No erasure issues.
    public static void sumInts(int... numbers) {
        System.out.println("\n=== 1. Safe Varargs (Primitives) ===");
        int sum = 0;
        for (int num : numbers) {
            sum += num;
            System.out.println("Adding: " + num);
        }
        System.out.println("Sum: " + sum + " (Array type: " + numbers.getClass() + ")");
    }

    // 2. GENERIC VARARGS: Compiler warns "Possible heap pollution".
    // Returns T[] exposes the Object[] pollution, causing ClassCastException.
    public static <T> T[] genericToArray(T... items) {
        System.out.println("\n=== 2. Generic Varargs (Pollution via Exposure) ===");
        System.out.println("Varargs array type: " + items.getClass());  // Always [Ljava.lang.Object;
        System.out.println("Item 0 class: " + items[0].getClass());
        System.out.println("Item 1 class: " + items[1].getClass());
        return items;  // EXPOSES pollution!
    }

    // 3. DIRECT POLLUTION: Varargs -> Object[] -> Wrong type insert -> Boom!
    public static void polluteHeap(List<String>... stringLists) {
        System.out.println("\n=== 3. Direct Heap Pollution ===");
        List<String> list1 = Arrays.asList("A", "B", "C");
        List<String> list2 = Arrays.asList("D", "E", "F");

        // Simulate passing 2 lists (index 0,1); index 2 empty initially.
        stringLists = new List[]{list1, list2, new ArrayList<>()};

        Object[] objects = stringLists;  // Bridge: List<String>[] -> Object[]
        objects[2] = Arrays.asList(10, 20);  // POLLUTE: Insert List<Integer>!

        System.out.println("Safe access: " + stringLists[0].get(0));  // "A"
        System.out.println("Safe access: " + stringLists[1].get(1));  // "E"
        // This throws ClassCastException: Integer not String
        System.out.println("POLLUTED: " + stringLists[2].get(1));
    }

    // 4. @SafeVarargs: Suppresses warning (for static/final methods).
    // SAFE if you DON'T expose/modify array. Just iterate/print.
    @SafeVarargs
    public static void safePrintLists(List<String>... lists) {
        System.out.println("\n=== 4. @SafeVarargs (Safe Usage) ===");
        for (List<String> list : lists) {
            System.out.println("List: " + list);
        }
        // No exposure/return/cast -> No pollution risk.
    }
    
    // 5. Object[] Storage Pollution: Compiles fine, CRASHES at runtime!
    public static void objectStoragePollution(List<String>... stringLists) {
        System.out.println("\n=== 5. Object[] Storage Pollution (REAL CRASH!) ===");
        
        // Store varargs in Object[] (legal due to erasure)
        Object[] storage = stringLists;
        List<String> list1 = Arrays.asList("X", "Y");
        List<String> list2 = Arrays.asList("Z");
        
        storage[0] = list1;  // Safe
        storage[1] = list2;  // Safe
        
        // POLLUTION: External code/reflection sneaks wrong type in!
        storage[2] = Arrays.asList(100, 200);  // List<Integer> in List<String>[] slot!
        
        // CRASH! JVM sees List<Integer> where List<String> expected
        String first = (String) ((List<String>) storage[2]).get(0);  // ClassCastException!
    }


    public static void main(String[] args) {
        System.out.println("Java Varargs & Heap Pollution Demo\n");

        // 1. Safe primitive varargs
        sumInts(1, 2, 3, 4);

        // 2. Generic varargs pollution (via return)
        try {
            String[] strings = genericToArray("Hello", "World");  // WARNING here!
            // String[] strings = genericToArray("Hello", "World", 123);  // WARNING here! Compile-time Exception will be thrown..
            System.out.println("Returned array: " + Arrays.toString(strings));
        } catch (ClassCastException e) {
            System.out.println("BOOM! ClassCastException: " + e.getMessage());
            // Output: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;
        }

        // 3. Uncomment to see direct pollution (will crash)
        // polluteHeap();

        // 4. Safe with annotation
        safePrintLists(
            Arrays.asList("Safe1"),
            Arrays.asList("Safe2", "Safe3")
        );
        
        // 5. Object storage pollution (compiles ‚Üí runtime crash)
        try {
            objectStoragePollution(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());
            System.out.println("The Above Method call will run into an Exception so it will interrupt the current flow of execution");
        } catch (ClassCastException e) {
            System.out.println("üí• SECTION 5 CRASH: " + e.getMessage());
        }


        System.out.println("\nDemo Complete. Warnings shown on compile due to generics+varargs.");
    }
}


/**
 * 
   
   OUTPUT: 1 
   
   Java Varargs & Heap Pollution Demo


    === 1. Safe Varargs (Primitives) ===
    Adding: 1
    Adding: 2
    Adding: 3
    Adding: 4
    Sum: 10 (Array type: class [I)
    
    === 2. Generic Varargs (Pollution via Exposure) ===
    Varargs array type: class [Ljava.lang.String;
    Item 0 class: class java.lang.String
    Item 1 class: class java.lang.String
    Returned array: [Hello, World]
    
    === 4. @SafeVarargs (Safe Usage) ===
    List: [Safe1]
    List: [Safe2, Safe3]
    
    === 5. Object[] Storage Pollution (REAL CRASH!) ===
    üí• SECTION 5 CRASH: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap')
    
    Demo Complete. Warnings shown on compile due to generics+varargs.
    
    <------------------------------END------------------------------------>
    
    OUTPUT: 2 (Exception thrown in section-3)
    
    === 3. Direct Heap Pollution ===
    Safe access: A
    Safe access: E
    Exception in thread "main" java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap')
            at Main.polluteHeap(Main.java:111)
            at Main.main(Main.java:162)
            
   
 */
 
